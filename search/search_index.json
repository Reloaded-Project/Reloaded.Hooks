{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Project Reloaded: Hooking WTF You can unit test function hooks!?"},{"location":"#introduction","title":"Introduction","text":"<p>Reloaded.Hooks is a library for intercepting and modifying existing binary functions on <code>x86</code> and <code>x64</code> machines. It is most often used to either intercept Win32 API calls (e.g. <code>NtCreateFile</code> to find out what files the current process is loading) or to patch existing functions within a program; e.g. patching software at runtime.</p> <p>If this concept is unfamiliar to you; I would suggest to research the term <code>Hooking</code> while reading the documentation.</p> <p>Reloaded.Hooks is a managed alternative to native libraries such as <code>MinHook</code> and <code>Detours</code>, targeted at tackling more advanced/difficult use cases; such as when functions do not use standard calling conventions.</p>"},{"location":"#feature-highlights","title":"Feature Highlights","text":"<ul> <li>Support for x86 and x64 architectures.</li> <li>Call &amp; hook unmanaged functions with custom calling conventions.</li> <li>Stack function hooks. You can hook already hooked functions as many times as you like.</li> <li>Mid function x86/x64 assembly hooks; similar to the likes of <code>Cheat Engine</code>.</li> <li>Highly compatible. Detects &amp; patches common variations of existing function hooks when hooking. Hook functions hooked by other libraries; this feature is unique to Reloaded.Hooks. </li> <li>Generate native wrapper functions for converting between custom calling conventions. e.g. Stdcall to Fastcall converter.</li> <li>Many lower level utility functions allowing you to deal with things like Virtual Function Tables. </li> </ul>"},{"location":"#contributions","title":"Contributions","text":"<p>As with the standard for all of the <code>Reloaded-Project</code>, repositories; contributions are very welcome and encouraged.</p> <p>Feel free to implement new features, make bug fixes or suggestions so long as they are accompanied by an issue with a clear description of the pull request.</p> <p>If you are implementing new features, please do provide the appropriate unit tests to cover the new features you have implemented; try to keep the coverage high \ud83d\ude0a.</p>"},{"location":"#authors-contributions","title":"Authors &amp; Contributions","text":"<ul> <li> <p>Reloaded.Hooks uses the <code>Flat Assembler</code> (FASM) by Tomasz Grysztar.</p> </li> <li> <p>Reloaded.Hooks uses the <code>Iced</code> library by 0xd4d.</p> </li> </ul>"},{"location":"#legacy","title":"Legacy","text":"<ul> <li>Older versions of Reloaded.Hooks used the <code>SharpDisasm</code> library by Justin Stenning (spazzarama), a partial port of Udis86 by Vivek Thampi. Both of these libraries are originally distributed under the under the 2-clause \"Simplified BSD License\". </li> </ul>"},{"location":"AssemblyHooks/","title":"Assembly Hooks","text":"<p>For advanced users requiring very specialized uses (e.g. Mid Function Hooks), a Cheat-Engine like pure assembly code hook is available.</p> <p>This hook replaces the original application code with a jump to your own custom supplied code and (optionally) the original code in either of the three combinations:</p> <ul> <li>Discard Original Code</li> <li>Execute Custom Code First</li> <li>Execute Custom Code Last</li> </ul>"},{"location":"AssemblyHooks/#an-example","title":"An Example","text":"<p>Consider the following function.</p> <pre><code>// Returns the value of `a + b`\n[UnmanagedFunctionPointer(CallingConvention.Cdecl)]\npublic delegate int AddFunction(int a, int b); \n</code></pre> <p>In native assembly, this function can be represented by something like the following:</p> <pre><code>// Unoptimized code, for demonstration only.\npush _ebp,\nmov _ebp, _esp,\nmov _eax, [_ebp + wordSize * 2], // Left Parameter\nmov _ecx, [_ebp + wordSize * 3], // Right Parameter\nadd _eax, _ecx,\npop _ebp,\nret\n</code></pre> <p><code>Macros: (wordSize = 4 on x86, wordSize = 8 on x64), (_ebp is ebp on x86, _ebp is rbp on x64), etc.</code></p> <p>This function could, for example be manipulated to return <code>result + 1</code>, in any of the following ways.</p>"},{"location":"AssemblyHooks/#discarding-original-code","title":"Discarding Original Code","text":"<p>Straight up replace the original code with your own.</p> <pre><code>int wordSize = IntPtr.Size;\nstring[] addFunction = \n{\n    $\"{_use32}\",\n    $\"push {_ebp}\",\n    $\"mov {_ebp}, {_esp}\",\n\n    $\"mov {_eax}, [{_ebp} + {wordSize * 2}]\", // Left Parameter\n    $\"mov {_ecx}, [{_ebp} + {wordSize * 3}]\", // Right Parameter\n    $\"add {_eax}, 1\",                         // Left Parameter\n};\n\n_addNoOriginalHook = new AsmHook(addFunction, addressOfNativeCode, AsmHookBehaviour.DoNotExecuteOriginal).Activate();\n</code></pre>"},{"location":"AssemblyHooks/#executing-original-code-first","title":"Executing Original Code First","text":"<pre><code>string[] addFunction =\n{\n    $\"{_use32}\",\n    $\"add {_eax}, 1\", // Left Parameter - Should have already been copied from stack.\n};\n\n_addAfterOriginalHook = new AsmHook(addFunction, addressOfNativeCode, AsmHookBehaviour.ExecuteAfter).Activate();\n</code></pre>"},{"location":"AssemblyHooks/#executing-original-code-last","title":"Executing Original Code Last","text":"<pre><code>int wordSize = IntPtr.Size;\nstring[] addFunction =\n{\n    $\"{_use32}\",\n    $\"add [{_esp} + {wordSize * 1}], byte 1\", // Add 1 to left parameter on stack.\n};\n\n_addBeforeOriginalHook = new AsmHook(addFunction, addressOfNativeCode, AsmHookBehaviour.ExecuteFirst).Activate();\n</code></pre>"},{"location":"AssemblyHooks/#whats-original-code","title":"What's \"Original Code\" ?","text":"<p>Answer: The minimal amount of x86/64 assembly instructions required to use 7 or more bytes.</p> <p>Understanding how this hook works helps a bit. Essentially what this hook does is place a <code>jmp</code> instruction at the location supplied as the <code>addressOfNativeCode</code> to your asm code. However, as the jump to your code overwrites the original code, something has to be done with that original code.</p> <p>What this hook does is it calculates the minimal amount of assembly instructions (starting from <code>addressOfNativeCode</code>) necessary to free up space for the <code>jmp</code> instruction. That is the minimal amount of instructions that uses &gt;= 7 bytes of space. Those instructions are referred to as the \"original code\". Depending on your preference, this code is either discarded or inserted before/after your own code.</p> <p>In other words; before you use this hook, you have to look at your disassembly and determine the minimum amount of instructions what take &gt;- 7 bytes. When <code>Reloaded.Hooks</code> does its work; that will be the \"original code\". As such, this hook is reserved for advanced users.</p> <p>(Note: A bit more actually happens under the hood to enable the <code>Disable/Enable</code> toggle, but this is the simple version).</p>"},{"location":"Benchmarks/","title":"Benchmarks","text":"<p>Sample benchmarks of function hooks.</p>"},{"location":"Benchmarks/#hardware","title":"Hardware","text":"<pre><code>BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042\nIntel Core i7-4790K CPU 4.00GHz (Haswell), 1 CPU, 8 logical and 4 physical cores\n.NET Core SDK=5.0.200-preview.20601.7\n  [Host]     : .NET Core 5.0.1 (CoreCLR 5.0.120.57516, CoreFX 5.0.120.57516), X64 RyuJIT\n  Job-EJHKEF : .NET Core 5.0.1 (CoreCLR 5.0.120.57516, CoreFX 5.0.120.57516), X64 RyuJIT\n\nPlatform=X64  Toolchain=64 bit cli  \n</code></pre>"},{"location":"Benchmarks/#benchmarked-methods","title":"Benchmarked Methods","text":"<p>The benchmark measures the time taken to execute the following function 1 million (1,000,000) times:</p> <p><code>static int Add(int a, int b) { return a + b; }</code></p> <pre><code>|             Method | Description\n|------------------- | -----------\n|     ManagedInlined | Execute an inlined version of the code.\n|            Managed | Execute a non-inlined version of the code.\n| ManagedUnoptimized | Execute an unoptimized version of the code. (Calling Convention Compliant)\n|      NoHookPointer | Execute a native assembly version of the code using C#9 function pointers (calli)\n|     NoHookDelegate | Execute a native assembly version of the code using Delegates (Marshal.GetDelegateForFunctionPointer)\n|       DelegateHook | Execute a hooked version using delegates.\n|        FuncPtrHook | Execute a hooked version using function pointers.\n</code></pre> <p><code>ManagedInlined</code> stack:</p> <ul> <li>.net (function)</li> </ul> <p><code>Managed</code> stack:</p> <ul> <li>.net (implementation)</li> <li>.net (function)</li> </ul> <p><code>ManagedUnoptimized</code> stack:</p> <ul> <li>.net (implementation, calling convention compliant)</li> <li>.net (function)</li> </ul> <p><code>NoHookPointer</code> stack:</p> <ul> <li>native (via function pointer)</li> <li>.net to native transition</li> <li>.net (function) </li> </ul> <p><code>NoHookDelegate</code> stack:</p> <ul> <li>native (via function pointer)</li> <li>.net to native transition</li> <li>.net delegate code</li> <li>.net (function) </li> </ul> <p><code>DelegateHook</code> stack:</p> <ul> <li>native</li> <li>.net to native transition</li> <li>.net delegate code</li> <li>.net (hook function)</li> <li>.net delegate code</li> <li>native to .net transition</li> <li>native</li> <li>.net to native transition</li> <li>.net delegate code</li> <li>.net (function) </li> </ul> <p><code>FuncPtrHook</code> stack:</p> <ul> <li>native</li> <li>.net to native transition</li> <li>.net (hook function)</li> <li>native to .net transition</li> <li>native</li> <li>.net to native transition</li> <li>.net (function) </li> </ul>"},{"location":"Benchmarks/#x86-benchmarks","title":"X86 Benchmarks","text":"<pre><code>|             Method |        Mean |     Error |    StdDev |\n|------------------- |------------:|----------:|----------:|\n|     ManagedInlined |    448.7 \u03bcs |   2.89 \u03bcs |   2.71 \u03bcs |\n|            Managed |  1,754.0 \u03bcs |   9.40 \u03bcs |   7.34 \u03bcs |\n| ManagedUnoptimized |  1,992.6 \u03bcs |  20.04 \u03bcs |  17.76 \u03bcs |\n|      NoHookPointer |  2,661.3 \u03bcs |  16.87 \u03bcs |  14.96 \u03bcs |\n|     NoHookDelegate | 10,787.7 \u03bcs | 123.28 \u03bcs | 115.32 \u03bcs |\n|       DelegateHook | 41,242.1 \u03bcs | 226.90 \u03bcs | 201.14 \u03bcs |\n|        FuncPtrHook | 11,825.8 \u03bcs |  54.23 \u03bcs |  48.07 \u03bcs |\n</code></pre>"},{"location":"Benchmarks/#x64-benchmarks","title":"X64 Benchmarks","text":"<pre><code>|             Method |        Mean |     Error |    StdDev |\n|------------------- |------------:|----------:|----------:|\n|     ManagedInlined |    448.6 \u03bcs |   1.90 \u03bcs |   1.78 \u03bcs |\n|            Managed |  1,583.8 \u03bcs |   8.50 \u03bcs |   7.53 \u03bcs |\n| ManagedUnoptimized |  1,820.4 \u03bcs |  20.18 \u03bcs |  15.75 \u03bcs |\n|      NoHookPointer |  6,958.4 \u03bcs |  20.41 \u03bcs |  17.04 \u03bcs |\n|     NoHookDelegate | 16,784.0 \u03bcs | 111.56 \u03bcs | 104.35 \u03bcs |\n|       DelegateHook | 55,987.3 \u03bcs | 456.96 \u03bcs | 405.08 \u03bcs |\n|        FuncPtrHook | 24,694.2 \u03bcs | 157.92 \u03bcs | 123.29 \u03bcs |\n</code></pre>"},{"location":"Benchmarks/#notes","title":"Notes","text":"<ul> <li>A close estimate of the native to .net transition can be calculated with <code>NoHookPointer - ManagedUnoptimized</code>.</li> <li>Calling a function using a delegate is almost as expensive as full function hook using function pointers.</li> <li>If absolute performance is a must (e.g. hooking graphics APIs called 100,000+ times per second), you should probably use native code instead.</li> <li>Some improved performance may be seen in the future based on a possible implementation of CallConvSuppressGCTransition.</li> </ul>"},{"location":"FunctionPointers/","title":"Function Pointers","text":"<p>With the release of .NET 5 and C# 9.0, <code>Reloaded.Hooks</code> also additionally provides support for the usage of function pointers for those interested in maximizing performance. </p> <p>Using function pointers reduces overhead in the native &lt;=&gt; managed transition as we can skip delegates altogether and under the hood, use the efficient <code>calli</code> IL opcode. Outside of the quest of achieving performance however, the usage of function pointers is not recommended.</p>"},{"location":"FunctionPointers/#compromises-with-function-pointers","title":"Compromises with Function Pointers","text":"<ul> <li>Static functions only.</li> <li>No compile-time checking (no compile error if your function doesn't match defined pointer).</li> <li> <p>No marshalling.</p> <ul> <li>Do it yourself. e.g. <code>Marshal.StringToHGlobalAnsi</code> and <code>Marshal.FreeHGlobal</code> for ANSI strings.</li> </ul> </li> <li> <p>No pointer types/ref/out (limitation of generics). </p> <ul> <li>You should use struct wrappers like <code>Reloaded.Memory</code>'s BlittablePointer.</li> <li>Then in your actual <code>UnmanagedCallersOnly</code> function declaration use raw pointers. There is an implicit conversion for <code>BlittablePointer</code>.</li> </ul> </li> <li> <p>Documentation: Cannot document parameter types outside of including the info directly in the struct description.</p> </li> </ul>"},{"location":"FunctionPointers/#defining-functions","title":"Defining Functions","text":"<p>As C# currently doesn't support named function pointers, we have to improvise a bit.</p> <p>In order to define a structure, you should define a struct with a single field of type <code>FuncPtr</code>. The generic type arguments to the <code>FuncPtr</code> are the arguments to your function pointer and the return type.</p> <pre><code>// Parameter 1 is `int`\n// Parameter 2 is `int`\n// Return type is `int`\n[Function(CallingConventions.Cdecl)]\npublic struct CalculatorFunction { public FuncPtr&lt;int, int, int&gt; Value; }\n</code></pre> <p>You should then be able to use (<code>CalculatorFunction</code>) in place of the regular delegate in all common APIs.</p> <p>Note: If no value is returned, consider using <code>Reloaded.Hooks.Definitions.Structs.Void</code> as the return parameter to help readability.</p>"},{"location":"FunctionPointers/#calling-functions","title":"Calling Functions","text":"<p>Calling functions is the same as with delegates, simply use the <code>Invoke</code> function of the pointer inside your struct.</p> <pre><code>// Alias can be set at the top of the .cs file.\nprivate CalculatorFunction _addFunctionPointer;\n\nvoid makeFunctionPointer() \n{\n    var addFuncPointer = ReloadedHooks.Instance.CreateWrapper&lt;CalculatorFunction&gt;((long)_nativeCalculator.Add, out var _);\n    var three = addFuncPointer.Value.Invoke(1, 2); \n}\n</code></pre> <p>Note: There are overloads for common calling conventions <code>InvokeStdcall</code>, <code>InvokeCdecl</code> and <code>InvokeThiscall</code>. Invoke is equivalent to <code>InvokeStdcall</code>.</p>"},{"location":"FunctionPointers/#hooking-functions","title":"Hooking Functions","text":"<p>Hooking functions using poitners requires .NET 5; due to the necessity of using the <code>UnmanagedCallersOnly</code> attribute.</p> <pre><code>/* Hook object. */\nprivate static IHook&lt;CalculatorFunction&gt; _addHook;\n\n// Reloaded.Hooks assumes function pointners are `Stdcall` on Windows (.NET default).\n// You should therefore use `CallConvStdcall` with your hook functions and use \n// Invoke/InvokeStdcall for calling the original function.\n[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]\nstatic int AddHookFunction(int a, int b) =&gt; _addHook.OriginalFunction.Value.Invoke(a, b) + 1;\n\npublic unsafe void HookAdd()\n{\n    _addHook = ReloadedHooks.Instance.CreateHook&lt;CalculatorFunction&gt;((delegate*unmanaged[Stdcall]&lt;int, int, int&gt;)&amp;AddHookFunction, (long)_nativeCalculator.Add).Activate();\n}\n</code></pre> <p>For your <code>UnmanagedCallersOnly</code> function please use raw pointers in places of <code>BlittablePointer</code> (where applicable). There is an implicit conversion between the two so no manual conversions will be necessary when calling the original function again. </p> <p>There is currently an issue in the runtime where generics aren't properly checked for blittability with <code>UnmanagedCallersOnly</code>.</p>"},{"location":"FunctionPointers/#hooking-via-reflection","title":"Hooking via Reflection","text":"<p>Experimental: Thorough testing not yet conducted.</p> <pre><code>/* Hook object. */\nprivate static IHook&lt;CalculatorFunction&gt; _addHook;\n\n[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]\nstatic int AddHookFunction(int a, int b) =&gt; _addHook.OriginalFunction.Value.Invoke(a, b) + 1;\n\npublic unsafe void HookAdd()\n{\n    _addHook = ReloadedHooks.Instance.CreateHook&lt;CalculatorFunction&gt;(typeof(ThisClass), nameof(AddHookFunction), (long)_nativeCalculator.Add).Activate();\n}\n</code></pre> <p>Writing the cast to a function pointer can be tedious. As such, Reloaded.Hooks provides overloads which allow you to select a static function via reflection using the containing class and function name.</p> <p>Note: Local functions are not supported.</p>"},{"location":"GettingStarted/","title":"Getting Started","text":""},{"location":"GettingStarted/#introduction","title":"Introduction","text":"<p>In this article, will quickly-ish demonstrate simple usage allowing you to get started with Reloaded.Hooks.</p> <p>As this library, was originally created to deal with modifying and reverse engineering games; many of the examples in this documentation show snippets of real game functions as opposed to common APIs. That said, nothing changes when hooking arbitrary APIs.</p>"},{"location":"GettingStarted/#adding-reloadedhooks-to-your-project","title":"Adding Reloaded.Hooks to your project.","text":"<ol> <li>Open/Create project in Visual Studio.</li> <li>Right-click your project within the Solution Explorer and select \u201cManage NuGet Packages\u2026\u201d.</li> <li>Search for \"Reloaded.Hooks\u201d.</li> <li>Install the package.</li> </ol>"},{"location":"GettingStarted/#prologue-definiting-functions","title":"Prologue: Definiting Functions","text":"<p>Calling, hooking and performing other operations with native functions with Reloaded.Hooks is performed through the use of delegate declarations.</p> <p>Reloaded.Hooks' main library is able to create individual delegate instances given supplied function addresses in memory - allowing you to use native functions as if they were your own.</p>"},{"location":"GettingStarted/#defining-reloaded-compatible-delegates","title":"Defining Reloaded-Compatible Delegates","text":"<p>Defining delegates to call native functions under Reloaded.Hooks is performed just like defining regular delegates with only one catch. You must inform Reloaded.Hooks of the kind of function you are going to call with the use of Reloaded's own <code>FunctionAttribute</code>.</p> <p>There are two <code>FunctionAttribute</code>(s), namely <code>X86.FunctionAttribute</code> and <code>X64.FunctionAttribute</code> for x86 and x64 respectively. Depending on your project you may wish to apply one, the other or both.</p> <p>Note: Examples bwlow have been lifted from real pieces of source code.</p>"},{"location":"GettingStarted/#example-native-cdecl-function","title":"Example: Native CDECL Function","text":"<pre><code>/* RenderWare Graphics | Function that is step one to widescreen hacks in RenderWare games. */\n[Function(CallingConventions.Cdecl)]\npublic delegate void RwCameraSetViewWindow(ref RWCamera RwCamera, ref RWView view);\n</code></pre>"},{"location":"GettingStarted/#example-function-with-registers-as-parameters","title":"Example: Function with registers as parameters","text":"<p>Info</p> <p>In the real world, compilers will often optimise function calls to optimise for performance. This will often lead to the function using non-standard conventions, such e.g. accepting parameters via registers where normally the stack should be used.  </p> <p>This is more common in x86 (32-bit) applications rather than x64 applications.  </p> <p>Reloaded.Hooks allows for mapping parameters to given registers.  </p> <pre><code>/// &lt;summary&gt;\n/// Reads a ANM/HAnim stream from a .ONE archive. Returns address of a decompressed ANM file.\n/// &lt;/summary&gt;\n/// &lt;param name=\"fileIndex\"&gt;[EAX] The index of the file inside the .ONE archive (starting with 2)&lt;/param&gt;\n/// &lt;param name=\"addressToDecompressTo\"&gt;[ECX] The address to which the file inside the ONE archive will be decompressed to.&lt;/param&gt;\n/// &lt;param name=\"thisPointer\"&gt;\"This\" pointer for the ONEFILE class instance.&lt;/param&gt;\n/// &lt;returns&gt;The address containing the read in ANM (RenderWare Hierarchical Animation) stream.&lt;/returns&gt;\n[Function(new[] { Register.eax, Register.ecx }, Register.eax, StackCleanup.Callee)]\npublic delegate int OneFileLoadHAnimation(int fileIndex, void* addressToDecompressTo, ref ONEFILE thisPointer);\n/* Lifted from a disassembly of Sonic Heroes */\n</code></pre> <p>This was an example of a custom function with the following properties:</p> <ul> <li>Two parameters (left to right) in registers <code>EAX</code> and <code>ECX</code>. </li> <li>Return register of <code>EAX</code>. </li> <li>\"Callee\" stack cleanup, i.e. the stack pointer is reset at the end of the function either via <code>ret X</code> (XXX Stdcall) or <code>add esp, X</code>. </li> </ul> <p>Those with some experience in reverse engineering might know that the popular IDA decompiler would identify such function as <code>userpurge</code>.</p> <p>For custom functions, under the hood <code>Reloaded.Hooks</code> creates wrappers that automatically convert between calling conventions such as the special one above that uses registers. These wrappers are actually what will be called behind the scenes as you call/hook your native functions, doing all the difficult work for you \u2764.</p>"},{"location":"GettingStarted/#deciphering-the-function-signature","title":"Deciphering the Function Signature","text":"<p>Info</p> <p>Some disassemblers may contain useful information about how the function is called. Below is guidance on deciphering the function signatures in some common disassemblers.  </p> <p>Please note that disassemblers are not perfect; they can and will sometimes make mistakes.</p> <p>IDA Pro (Decompiler): <pre><code>// Example\nvoid* __userpurge OneFileLoadHAnimation@&lt;eax&gt;(RwUInt32 type@&lt;eax&gt;, void *dest@&lt;ecx&gt;, ONEFILE *this)\n\n// Breakdown\nFUNCTION_NAME@&lt;eax&gt; in function name specifies return register is EAX.\ntype@&lt;eax&gt; specifies the `type` argument is passed via EAX register.\ndest@&lt;ecx&gt; specifies the `dest` argument is passed via ECX register.\nremaining parameters are passed via stack.\n\n// Extra Info (IDA Specific)\n_userpurge == 'Callee' Stack Cleanup\n_usercall == 'Caller' Stack Cleanup\n</code></pre></p> <p>Ghidra: </p> <p>Right click function name and click <code>Edit Function</code>. Inside the dialog, you will find the following:  </p> <p> </p> <p>Note: Ghidra did not disassemble this correctly; I manually fixed this function for this example.  </p> <p>Binary Ninja:</p> <p>This one is pretty self explanatory.  </p> <pre><code>// Example\nvoid* __stdcall OneFileLoadHAnimation(int32_t arg1 @ eax, char* arg2 @ ecx, char* arg3)\n</code></pre> <p>General: Some disassemblers might not provide information on return registers and/or stack cleanup because they are implied by the given convention (such as <code>__stdcall</code>). Consider using the following presets in <code>Reloaded.Hooks</code> to determine these settings.  </p> <ul> <li>X86 Calling Conventions (Presets)</li> <li>X64 Calling Conventions (Presets)</li> </ul>"},{"location":"GettingStarted/#important-note-about-the-api","title":"Important Note About the API","text":"<p>This is just a quick note before we introduce any direct code examples.</p> <p>To make things convenient, high level functions for all the features of the library are available within the <code>ReloadedHooks</code> class (<code>Reloaded.Hooks.ReloadedHooks</code>). These automatically detect if the current process is x86/x64 and use the appropriate underlying API. </p> <p>Please assume any usage of <code>ReloadedHooks</code> is an instance of <code>Reloaded.Hooks.ReloadedHooks</code>, which you can get easily via <code>ReloadedHooks.Instance</code>.</p>"},{"location":"GettingStarted/#calling-functions","title":"Calling Functions","text":"<p>In order to create an instance of your own custom delegate from a supplied function pointer, <code>ReloadedHooks.CreateWrapper</code> function is used. These will return you an instance of your requested function at address which you can call like a native function.</p> <pre><code>// Based on the delegate above.\nvar rwCameraSetViewWindow = ReloadedHooks.Instance.CreateWrapper&lt;RwCameraSetViewWindow&gt;(0x0064AC80);\n\n// You may now call the delegate instance/native/game fuction like if it was your own.\nrwCameraSetViewWindow(camera, view);\n</code></pre> <p>Regarding the other, more complex nonstandard function seen above that has been optimized out by the compiler - nothing changes. The process is exactly the same and saves you having to write what would otherwise be custom inline assembly in the C++ world.</p> <p>Lower level APIs:</p> <ul> <li><code>Reloaded.Hooks.X86.Wrapper</code></li> <li><code>Reloaded.Hooks.X64.Wrapper</code></li> </ul>"},{"location":"GettingStarted/#hooking-functions","title":"Hooking Functions","text":"<p>The hooking of arbitrary functions in Reloaded can also be considered a simple walk in the park. Below is a simple example of how you could hook a Win32 API to print out all files being opened by the current program.</p>"},{"location":"GettingStarted/#example-file-monitor","title":"Example: File Monitor","text":"<pre><code>/* You MUST store the returned hook to prevent the Garbage Collector \n   from freeing your hook function (CreateFileAImpl). */\n\n/* Fields */\nprivate IHook&lt;CreateFileA&gt; _createFileAHook; \n\n/* Constructor */\npublic SomeClass()\n{\n    // Get Address of Windows API function.\n    IntPtr kernel32Handle = LoadLibraryW(\"kernel32\");\n    IntPtr createFileAPointer = GetProcAddress(kernel32Handle, \"CreateFileA\");  \n\n    _createFileAHook = ReloadedHooks.Instance.CreateHook&lt;CreateFileA&gt;(CreateFileAImpl, (long)createFileAPointer).Activate();\n}\n\n/* Hook Function */\n\n/// &lt;summary&gt;\n/// Contains the implementation of the CreateFileA hook.\n/// Simply prints the file name to the console and calls + returns the original function.\n/// &lt;/summary&gt;\nprivate static IntPtr CreateFileAImpl(string filename, FileAccess access, FileShare share, IntPtr securityAttributes, FileMode creationDisposition, FileAttributes flagsAndAttributes, IntPtr templateFile)\n{\n    // If statement filters out non-files such as HID devices;\n    if (!filename.StartsWith(@\"\\\\?\\\"))\n        Bindings.PrintInfo($\"[CFA] Opening File {filename}\");\n\n    // Calls the original function we hooked and returns its value.\n    return _createFileAHook.OriginalFunction(filename, access, share, securityAttributes, creationDisposition, flagsAndAttributes, templateFile);\n}\n</code></pre> <p>There is nothing extra you need to do. <code>Reloaded.Hooks</code> handles everything for you under the hood such as calculating hook lengths and handling register parameters for special functions. You will never have to do silly error prone stuff such as writing custom inline assembler by hand. </p> <p>Reloaded's hooking code is really, really powerful, even patching common forms of hooks created by other programs and libraries for maximum compatibility (you can hook hooks!). For example, you can easily hook DirectX 9's <code>EndScene</code> or <code>Present</code> without breaking the Steam Overlay; this is something people normally struggle with and write dirty hacks to get around.</p> <p>Lower level APIs:</p> <ul> <li><code>Reloaded.Hooks.Hook</code></li> </ul>"},{"location":"GettingStarted/#marshalling-support","title":"Marshalling Support","text":"<p>As <code>Reloaded.Hooks</code> uses .NET delegates, for both hooking and calling function, there is support for extra features such as marshalling. Here is an example:</p> <pre><code>/*\n    Within native code this individual function would be expressed as \"int PlayADX(char* fileName)\",\n    here thanks to marshalling we are able to simply specify it as a string.\n\n    In this specific case, additionally, CharSet = CharSet.Ansi must be specified as the game from\n    which this function originates from did not use the Unicode encoding that is default in C#. \n*/\n\n[Function(CallingConventions.Cdecl)]\n[UnmanagedFunctionPointer(CallingConvention.Cdecl, CharSet = CharSet.Ansi)\npublic delegate int PlayADX(string fileName); \n/* Sourced from a clean room disassembly of Sonic Heroes */\n</code></pre>"},{"location":"GettingStarted/#pointers-to-net-functions","title":"Pointers to .NET Functions","text":"<p>No hacking adventure would be ever complete with pointers to our own functions.</p> <p><code>Reloaded.Hooks</code> supports this and as you'd expect, making life very easy for you. You can even make pointers to C# functions with custom calling conventions; e.g. effectively create a <code>fastcall</code> method in C#.</p> <p>Support for this functionality is provided through the use of the <code>CreateReverseWrapper</code> function. This returns a class, which contains a property <code>WrapperPointer</code> that can be used to call the C# function from native code.</p> <pre><code>/*  You MUST store the returned ReverseWrapper to prevent the Garbage Collector \n    from freeing your function (CSharpFastcallFunction). */\n\n// Define an x86 fastcall function (via template).\n// Microsoft Fastcall passes first two parameters in registers ECX, EDX and returns value in EAX.\n[Function(CallingConventions.Fastcall)]\npublic delegate void FastcallExample(int a, int b, int c);\n\n/* Fields */\nprivate IReverseWrapper&lt;FastcallExample&gt; _reverseFunctionWrapper;\nprivate FastcallExample                  _functionWrapper;\n\n/* Main/Init Method */\nvoid FastcallCSharpFunctionPointerTest()\n{\n    // Create wrapper to make our \"C# fastcall\" function.\n    _reverseFunctionWrapper = ReloadedHooks.Instance.CreateReverseWrapper&lt;FastcallExample&gt;(CSharpFastcallFunction);\n\n    // To prove our \"C# fastcall\" function works, let's just call it like a native function.\n    _functionWrapper = ReloadedHooks.Instance.CreateWrapper&lt;FastcallExample&gt;((long)_reverseFunctionWrapper.WrapperPointer);\n    _functionWrapper(1,2,3);\n}\n\n\n/* Function Implementation */\n\n/// &lt;summary&gt;\n/// When called through the address in reverseFunctionWrapper.Pointer,\n/// this function is now a \"fastcall\" function.\n/// &lt;/summary&gt;\n/// &lt;param name=\"a\"&gt;This number is passed via ECX register!&lt;/param&gt;\n/// &lt;param name=\"b\"&gt;This number is passed via EDX register!&lt;/param&gt;\n/// &lt;param name=\"c\"&gt;This number is on the stack.&lt;/param&gt;\nprivate static void CSharpFastcallFunction(int a, int b, int c)\n{\n    MessageBox.Show($\"{a + b + c}\");\n}\n</code></pre> <p>Lower level APIs:</p> <ul> <li><code>Reloaded.Hooks.X86.ReverseWrapper</code></li> <li><code>Reloaded.Hooks.X64.ReverseWrapper</code></li> </ul>"},{"location":"GettingStarted/#in-assembly-code","title":"In Assembly Code","text":"<p>If you would like to call managed C# code from assembly code generated at run-time (such as <code>AsmHook</code>), consider using the <code>ReloadedHooksUtilities.GetAbsoluteCallMnemonics</code> helper function to generate the appropriate x86/x64 call instruction.</p> <pre><code>// SomeFunction is a Stdcall C# function accepting two integers.\n// _reverseWrapAddFunction is a `ReverseWrapper`, it is a class member.\nstring[] function = \n{\n    $\"use32\",\n\n    // Backup registers meant to be saved by caller. \n    // Not always necessary but good practice to do so!\n    $\"{Utilities.PushCdeclCallerSavedRegisters()}\" \n\n    $\"push ecx\", // Right Parameter\n    $\"push edx\", // Left Parameter\n    $\"{Utilities.GetAbsoluteCallMnemonics(SomeFunction, out _reverseWrapAddFunction)}\",\n\n    // Restore backed up registers.\n    $\"{Utilities.PopCdeclCallerSavedRegisters()}\" \n    $\"ret\"\n};\n\n// You should reference the ReverseWrapper (out parameter) as long as you plan on using the\n// native/ASM function. Failure to do so will cause issues after Garbage Collection occurs. \n</code></pre> <p>The calling convention of your C# function is controlled by <code>UnmanagedFunctionPointerAttribute</code> for Delegates (default is <code>StdCall</code>). While not always necessary*, it is good practice that you wrap your call with <code>PushCdeclCallerSavedRegisters</code> and <code>PopCdeclCallerSavedRegisters</code> respectively (for both Cdecl and Stdcall). </p> <p>For a more advanced example, consider looking at CSharpFromAssembly.cs from Reloaded.Hooks' test code.</p> <p>* This depends on context; if using an assembly hook, the original function might be doing the backup/restore for you already. If you are unsure, you should always backup and restore.</p>"},{"location":"GettingStarted/#misc-performance-notes","title":"Misc Performance Notes","text":"<ul> <li>Reloaded has checks and 'hot paths' implemented to prevent creating unnecessary wrappers.</li> <li> <p>For example, if you call <code>CreateReverseWrapper&lt;T&gt;</code> for a function marked <code>Stdcall</code> with <code>FunctionAttribute</code> and the target function is already Stdcall, no wrapper will be generated and the input pointer will be returned.</p> </li> <li> <p>You can reduce the overhead of transitions between native code and .NET by using Function Pointers (C#9).</p> </li> </ul>"},{"location":"Utilities/","title":"Utilities","text":"<p>This section is a quick reference/directory to the various utility functions and classes available.</p>"},{"location":"Utilities/#reloadedhooks-ireloadedhooks","title":"ReloadedHooks &amp; IReloadedHooks","text":"<p><code>ReloadedHooks</code> is a one stop shop for this library, encompassing all main and commonly used functionality inside of a single class.</p> <p>For example:</p> <pre><code>_reloadedHooks.CreateWrapper&lt;NtCreateFile&gt;(ntCreateFile, out _);\n</code></pre> <p>Would be functionally equivalent to: <code>new X86.Wrapper.Create&lt;TFunction&gt;(function, out _);</code> or  <code>new X64.Wrapper.Create&lt;TFunction&gt;(function, out _);</code> depending on architecture of current process.</p> <p>If you are already familiar with <code>Reloaded.Hooks</code> as a library, everything inside <code>IReloadedHooks</code> should be self explanatory.</p>"},{"location":"Utilities/#function","title":"Function <p><code>Function&lt;T&gt;</code> is an API that wraps a native function given a pointer and instance of <code>IReloadedHooks</code>. </p> <p>For example, creating an instance of the class:</p> <pre><code>// _calculator.Add is a function address\n// _hooks is an instance of ReloadedHooks\n_addFunction = new Function&lt;Calculator.AddFunction&gt;((long)_calculator.Add, _hooks);\n</code></pre> <p>Allows you to more easily use common operations of the library.</p> <pre><code>// Hook Function\n_addHook = _addFunction.Hook(Hookfunction).Activate();\n\n// Call Function\n _addFunction.GetWrapper()(x, y);\n</code></pre> <p>The intended use of this class is to simplify usage when building APIs that can interface with a given process. For example: APIs that allow for hacking specific games.</p> <p>Remarks: The return value of <code>GetWrapper()</code> is cached, repeated calls will return the same results.</p>","text":""},{"location":"Utilities/#calling-function-pointers","title":"Calling Function Pointers <p>Should you ever find yourself needing to call functions that are pointed to by a pointer whose value constantly changes, <code>Reloaded.Hooks</code> provides you with a simple utility class to help you alleviate the pain of constantly changing function addresses.</p> <p>The utility class is simply named <code>FunctionPtr</code> and can be found at <code>Reloaded.Hooks.Tools</code> respectively - the usage is simple. Here is a small sample example:</p> <pre><code>// 0x123456 is the address of a pointer which points to a function of type MyCustomDelegate\n// MyCustomDelegate is a delegate marked with FunctionAttribute and UnmanagedFunctionPointerAttribute.\nFunctionPtr&lt;MyCustomDelegate&gt; functionPtr = new FunctionPtr&lt;MyCustomDelegate&gt;(0x123456);\n\n// Gets the address of our function (dereferences pointer).\nvar functionAddress = functionPtr.GetFunctionAddress(0); // Index: This class supports arrays of pointers.\n\n// Gets the delegate to use for calling the native function and calls the function.\n// You should this every time you intend to use the function pointer to call function. \nvar myCustomFunction = functionPtr.GetDelegate();\nmyCustomFunction(1000);\n</code></pre>","text":""}]}